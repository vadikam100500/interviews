Often i write docs, comments and readme.md on English.
But it's not that case. At first looking on project, i saw
Twisted and it will be a big trouble for me, because i see it at first.
Soo lets try.

- Первое что бросается в глаза это папка venv, причем со скрытым дубликатом.
    В venv версия python 3.6 будем от нее операться.
    В README.txt указано, что система на сервере: Ubuntu 20.04
    На сколько помню, в ней от коробки python 3.8,
    т.е. версии ниже будут поддерживаться
    Что касается venv и pip, они немного морально устарели.
    Альтернативы venv: poetry, dpm, docker
    Я буду использовать poetry, но на всякий случай оставлю requirements.txt
    Результат: venv удален.
    Установка python 3.6.8 в pyenv вызвала ошибку сигментирования, пришлось пропачивать,
    может стоит выбрать версию python выше?
- папка __pycache__ также не нужна
- в дублировании settings.py, смысла пока не вижу, но оставлю
- run-bot.bat, с аброкадаброй по запуску bot.py из под venv, не нужен - сервер на ubuntu,
    при желании активацию venv можно прописать в баш скрипте
- директорию .history тоже можно сносить
- оставлять данные сессии(dtohmahov.session), не лучшая идея
- в каждом файле на первой строке: # -*- coding: utf-8 -*- 
    Она была нужна для python2, как только появился python3, UTF-8 стандартная кодировка
- README обычно формата md, хотелось бы больше описания
Поверхностно пока все.

settings.py
- если код не будет выкладываться в открытые источники, то допустимо хранение секретных данных,
    но я предпочту хранить их как переменные окружения
- обьявляется список EXTRA_WORDS и ниже переопределяется с теми же значения в нижнем регистре,
    странно, но пока оставлю
- для чего HANDLED_CHATS записаны в форме ключ:значение пока не понятно
- хранение форматов дат пока сомнительно, но возможно часто используются, пусть будут

bot.py
- вынесу логику связанную с ботом в отдельный пакет вместе с extractor.py, если клиент будет
    вызываться из корневой дирректории
- учитывая, что у нас python 3.6, не буду использовать перенос строк c помощью обратного слэша,
    а также вместо форматирования старым стилем, будут использоваться f строки
- скорее всего проект переносился с python2
- навел порядок в импортах
- многократное нарушение PEP8:
    E501(строка больше 79 символов),
    E203(лишние пробелы перед оператором),
    E722(не правильное применение except)
- во всем проекте DATE_WITH_TIME_FORMAT используется только 1 раз, убрал из конфига
- logger, вынес в main перед стартом клиента, в идеале вынести в блок if __name__ == '__main__,
    но пока не понятно, как клиент будет вызываться, дату имени логфайлa локализовал под мск,
    в дирректории логов логи буду создаваться в дир bot/
- вынес TIME_ZONE в конфиг
- force_in_mem_today_actual_for_all:
    - название большое, но ничего не понятно
    - во всем файле в идеале сделать исключения конкретными, а не общими
- force_in_mem_update_today_extract_for_chat:
    chat_id должен быть строкой
- extractor_from_message вынес в extractor.py
    слишком много вложенных условий, как и в большинстве функций
    нет смысла оборачивать все try в message в любом случае будет text,
    который не будет пустым
    message.caption - такого значения в message нет, судя по докам и метода тоже
    в этой функции по сути нет смысла,
    можно сразу вызывать extract_from_text(apply_emoji_filter(message.text))
- apply_emoji_filter:
    Теперь убирает emoji, а флаги заменяет на ['Название страны']
    Библиотеку flag сношу она не нужна
- extract_from_text
    ... похаже дальше нет смысла комментировать, мне суток мало, даже чтобы парсер написать)

Самый банальный вариант продолжения с места, где я остановился, было бы такое:
Переписать все в один класс, при проходе по строке сообщения, если в ней нет суммы, прокэшировать ее 
и кэшировать до тех пор пока не встретится сумма, проитерироваться по списку фирм в конфиге, на совпадение
в закешированной строке. Далее создать экземпляр класса наподобие "Xiaomi(Firm)" и записывать в него данные.
Для упрощения получения и записи данных в идеале создать парсер, который соберет из крупного маркетплейса
названия всех моделей, что упростит соотношение и поиск или просто найти такой список в нете.
